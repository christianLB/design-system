import fs from 'fs-extra';
import path from 'path';
import { fileURLToPath } from 'url';
import { analyzeAndDocumentComponent } from './generate-docs-ai.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

interface ComponentFile {
  name: string;
  path: string;
  relativePath: string;
}

async function findAllComponents(componentsDir: string): Promise<ComponentFile[]> {
  const components: ComponentFile[] = [];

  async function scanDirectory(dir: string, baseDir: string = componentsDir) {
    const entries = await fs.readdir(dir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);

      if (entry.isDirectory()) {
        await scanDirectory(fullPath, baseDir);
      } else if (
        entry.isFile() &&
        entry.name.endsWith('.tsx') &&
        !entry.name.includes('.stories.') &&
        !entry.name.includes('.test.')
      ) {
        // Skip story and test files
        const componentName = path.basename(entry.name, '.tsx');
        const relativePath = path.relative(baseDir, fullPath);

        // Only include main component files (not index files)
        if (componentName !== 'index' && !componentName.includes('.d')) {
          components.push({
            name: componentName,
            path: fullPath,
            relativePath: relativePath,
          });
        }
      }
    }
  }

  await scanDirectory(componentsDir);
  return components;
}

async function generateDocumentationIndex(
  components: ComponentFile[],
  outputDir: string,
): Promise<void> {
  const indexContent = `# Component Documentation

This documentation is automatically generated by Claude Code Documentation System.

## Available Components

${components.map((comp) => `- [${comp.name}](./${comp.name}.md) - ${comp.relativePath}`).join('\n')}

## How to Use

Each component documentation includes:

- **Props Table**: Complete list of all props with types, requirements, and descriptions
- **Examples**: Code examples showing common usage patterns
- **Best Practices**: Guidelines for using the component effectively
- **Accessibility**: Information about accessibility features and compliance
- **Related Components**: Links to related components in the system

## Automated Generation

This documentation is automatically updated whenever components change. To regenerate:

\`\`\`bash
# Generate docs for all components
pnpm generate:docs:all

# Generate docs for a specific component
pnpm generate:docs src/components/ComponentName/ComponentName.tsx
\`\`\`

---

*Last updated: ${new Date().toISOString()}*
*Total components: ${components.length}*
`;

  await fs.writeFile(path.join(outputDir, 'README.md'), indexContent);
  console.log(`üìã Generated documentation index with ${components.length} components`);
}

async function generateComponentsManifest(
  components: ComponentFile[],
  outputDir: string,
): Promise<void> {
  const manifest = {
    version: '1.0.0',
    generated: new Date().toISOString(),
    totalComponents: components.length,
    components: components.map((comp) => ({
      name: comp.name,
      path: comp.relativePath,
      documentationPath: `${comp.name}.md`,
      storyPath: `../src/stories/generated/${comp.name}.stories.tsx`,
      examplePath: `examples/${comp.name}.examples.tsx`,
    })),
  };

  await fs.writeFile(path.join(outputDir, 'manifest.json'), JSON.stringify(manifest, null, 2));
  console.log(`üìÑ Generated components manifest`);
}

async function main() {
  const args = process.argv.slice(2);
  const componentsDir = args[0] || path.join(__dirname, '../src/components');
  const outputDir = args[1] || path.join(__dirname, '../docs/components');

  console.log(`üîç Scanning for components in: ${componentsDir}`);
  console.log(`üìù Output directory: ${outputDir}`);

  try {
    // Find all components
    const components = await findAllComponents(componentsDir);
    console.log(`‚úÖ Found ${components.length} components to document`);

    // Ensure output directory exists
    await fs.ensureDir(outputDir);

    // Generate documentation for each component
    const results = [];
    for (let i = 0; i < components.length; i++) {
      const component = components[i];
      console.log(`\nüìö [${i + 1}/${components.length}] Processing ${component.name}...`);

      try {
        const analysis = await analyzeAndDocumentComponent(component.path, {
          outputDir,
          generateStorybook: true,
          generateReadme: true,
          includeExamples: true,
        });

        results.push({
          component: component.name,
          success: true,
          props: analysis.props.length,
          examples: analysis.examples.length,
          accessibility: analysis.accessibility.length,
        });
      } catch (error) {
        console.error(`‚ùå Failed to process ${component.name}:`, error);
        results.push({
          component: component.name,
          success: false,
          error: error.message,
        });
      }
    }

    // Generate documentation index
    await generateDocumentationIndex(components, outputDir);

    // Generate manifest
    await generateComponentsManifest(components, outputDir);

    // Summary
    console.log(`\nüéâ Documentation generation completed!`);
    console.log(`üìä Summary:`);

    const successful = results.filter((r) => r.success);
    const failed = results.filter((r) => !r.success);

    console.log(`  ‚úÖ Successfully processed: ${successful.length} components`);
    if (failed.length > 0) {
      console.log(`  ‚ùå Failed to process: ${failed.length} components`);
      failed.forEach((f) => console.log(`    - ${f.component}: ${f.error}`));
    }

    if (successful.length > 0) {
      const totalProps = successful.reduce((sum, r) => sum + (r.props || 0), 0);
      const totalExamples = successful.reduce((sum, r) => sum + (r.examples || 0), 0);
      const totalAccessibility = successful.reduce((sum, r) => sum + (r.accessibility || 0), 0);

      console.log(`  üìù Total props documented: ${totalProps}`);
      console.log(`  üí° Total examples generated: ${totalExamples}`);
      console.log(`  ‚ôø Total accessibility features: ${totalAccessibility}`);
    }

    console.log(`\nüìÅ Output files:`);
    console.log(`  üìã Index: ${path.join(outputDir, 'README.md')}`);
    console.log(`  üìÑ Manifest: ${path.join(outputDir, 'manifest.json')}`);
    console.log(`  üìö Components: ${outputDir}/`);
    console.log(`  üìñ Stories: src/stories/generated/`);
    console.log(`  üí° Examples: ${outputDir}/examples/`);
  } catch (error) {
    console.error('‚ùå Error generating documentation:', error);
    process.exit(1);
  }
}

// Run if called directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}
