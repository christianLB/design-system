# Design System Styling Conventions

## Issue Identified

During development of the design system, we identified a fundamental inconsistency in how component styling is applied:

1. **Tailwind Utility Approach**: Some components (including earlier versions of Button) use Tailwind's utility classes with CSS variables, like:
   ```jsx
   className={clsx(
     'bg-[var(--primary)]',
     'text-[var(--primary-foreground)]'
   )}
   ```

2. **CSS Class Approach**: The design system's CSS in `index.css` defines specific component classes like:
   ```css
   [data-theme='futuristic'] .button--primary {
     background-color: var(--primary);
     color: var(--primary-foreground);
   }
   ```

This inconsistency led to styling not being properly applied, particularly in themed contexts.

## Decision

After evaluating both approaches, we've decided to standardize on the **CSS Class Approach** for the following reasons:

1. **Better Theme Integration**: Using CSS classes with `data-theme` selectors enables proper theme switching without component re-rendering
2. **Cleaner Component Code**: Components become simpler with fewer string literals and utility class combinations
3. **Improved Maintainability**: CSS changes can be made in one place (`index.css`) without modifying component code
4. **Better Performance**: Reduces the number of classes generated by Tailwind JIT

## Standard Pattern

Components should follow this pattern:

1. **Base Class**: Use a semantic base class for the component (e.g., `.btn` for buttons)
2. **Variant Classes**: Use BEM-like naming `component--variant` (e.g., `.button--primary`)
3. **Size Classes**: Use `component--size` (e.g., `.button--sm`, `.button--md`, `.button--lg`)
4. **State Classes**: Use `component--state` (e.g., `.button--disabled`)

### Example Component:

```jsx
const MyComponent = ({ variant = 'default', size = 'md', disabled, className, ...props }) => {
  const classes = clsx(
    'base-component', // Base component class
    `component--${variant}`, // Variant
    `component--${size}`, // Size
    disabled && 'component--disabled', // States
    className // Custom classes
  );
  
  return <div className={classes} {...props} />;
};
```

### Example CSS:

```css
/* Base component */
.base-component {
  /* Base styling shared by all variants */
}

/* Variants */
.component--default {
  /* Default variant */
}

.component--alternate {
  /* Alternate variant */
}

/* Sizes */
.component--sm {
  /* Small size */
}

.component--md {
  /* Medium size - the default */
}

/* Theme variants */
[data-theme='dark'] .component--default {
  /* Dark theme styling for default variant */
}

[data-theme='futuristic'] .component--default {
  /* Futuristic theme styling for default variant */
}
```

## Implementation Status

| Component | CSS Class Pattern | Tailwind Utility Pattern | Status |
|-----------|---------------------|-------------------------|--------|
| Button    | ✅ | ❌ | Refactored |
| Card      | ⚠️ | ⚠️ | Needs Audit |
| Input     | ⚠️ | ⚠️ | Needs Audit |
| ...       | ⚠️ | ⚠️ | Needs Audit |

## Audit Strategy

1. **Inventory**: Create a complete list of all components in the design system
2. **Analyze**: For each component, determine which styling approach it uses
3. **Prioritize**: Rank components by usage and complexity for refactoring
4. **Refactor**: Update components to use the CSS class pattern
5. **Test**: Verify styling works across all themes
6. **Document**: Update component documentation to reflect the styling approach

## Tailwind Guidelines

While we're standardizing on the CSS class pattern for components, Tailwind still has appropriate uses:

1. **Layout utilities**: Continue to use Tailwind for flex, grid, and spacing utilities
2. **One-off styles**: For simple, non-themed styles that don't need variants
3. **Rapid prototyping**: Before establishing a component pattern

However, any styled component with variants, sizes, or theme-specific styling should use the CSS class pattern.

## Migration Process

1. Update `index.css` with the component's base, variant, and size classes
2. Refactor the component to use these classes instead of utility classes
3. Verify visual consistency across themes
4. Update tests if necessary
